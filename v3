#include <stdio.h>
#include <iostream>
#include <vector>
//@#include <LiquidCrystal.h>
#define STEPPER_PIN_1 9
#define STEPPER_PIN_2 10
#define STEPPER_PIN_3 11
#define STEPPER_PIN_4 12
int button1 = 14;
int button2 = 13;
short jos = 2;
short fataa = 3;
short dreapta = 4;
short spate = 5;
short  stanga = 6;
short sus = 7;
short step_number = 0;

//@LiquidCrystal lcd(1, 15, 16, 17, 18, 19);

//@void setup() {
// Serial.begin(9600);
//pinMode(button1, INPUT_PULLUP);
//pinMode(button2, INPUT_PULLUP);
//pinMode(STEPPER_PIN_1, OUTPUT);
//pinMode(STEPPER_PIN_2, OUTPUT);
//pinMode(STEPPER_PIN_3, OUTPUT);
//pinMode(STEPPER_PIN_4, OUTPUT);
//pinMode(stanga, OUTPUT);
//pinMode(dreapta, OUTPUT);
//pinMode(jos, OUTPUT);
//pinMode(sus, OUTPUT);
//pinMode(fataa, OUTPUT);
//pinMode(spate, OUTPUT);
//lcd.begin(16, 2);
//@}
///////////////////////////////

//void reglare(short fata_cub, float unghi){
//
//    short pasi = 0;
//    digitalWrite(fata_cub, LOW);
//    delay(10);
//    while(pasi < 64*unghi){
//        OneStep(false);
//        pasi ++;
//        delay(8);
//    }
//    pasi = 86*unghi;
//    delay(100);
//    digitalWrite(fata_cub,HIGH);
//    delay(10);
//}
//void mutare_up(short fata_cub){
//
//    short pasi = 0;
//    digitalWrite(fata_cub, LOW);
//    delay(10);
//    while(pasi < 64*8){
//        OneStep(false);
//        pasi ++;
//        delay(8);
//    }
//    pasi = 86*8;
//    delay(100);
//    digitalWrite(fata_cub,HIGH);
//    delay(10);
//}
//void mutare_down(short fata_cub){
//
//    short pasi = 0;
//    digitalWrite(fata_cub, LOW);
//    delay(10);
//    while(pasi < 64*8){
//        OneStep(true);
//        pasi ++;
//        delay(8);
//    }
//    pasi = 86*8;
//    delay(100);
//    digitalWrite(fata_cub,HIGH);
//    delay(10);
//}

//void OneStep(bool dir){
//    if(dir){
//        switch(step_number){
//            case 0:
//                digitalWrite(STEPPER_PIN_1, HIGH);
//                digitalWrite(STEPPER_PIN_2, LOW);
//                digitalWrite(STEPPER_PIN_3, LOW);
//                digitalWrite(STEPPER_PIN_4, LOW);
//                break;
//            case 1:
//                digitalWrite(STEPPER_PIN_1, LOW);
//                digitalWrite(STEPPER_PIN_2, HIGH);
//                digitalWrite(STEPPER_PIN_3, LOW);
//                digitalWrite(STEPPER_PIN_4, LOW);
//                break;
//            case 2:
//                digitalWrite(STEPPER_PIN_1, LOW);
//                digitalWrite(STEPPER_PIN_2, LOW);
//                digitalWrite(STEPPER_PIN_3, HIGH);
//                digitalWrite(STEPPER_PIN_4, LOW);
//                break;
//            case 3:
//                digitalWrite(STEPPER_PIN_1, LOW);
//                digitalWrite(STEPPER_PIN_2, LOW);
//                digitalWrite(STEPPER_PIN_3, LOW);
//                digitalWrite(STEPPER_PIN_4, HIGH);
//                break;
//        }
//    }else{
//        switch(step_number){
//            case 0:
//                digitalWrite(STEPPER_PIN_1, LOW);
//                digitalWrite(STEPPER_PIN_2, LOW);
//                digitalWrite(STEPPER_PIN_3, LOW);
//                digitalWrite(STEPPER_PIN_4, HIGH);
//                break;
//            case 1:
//                digitalWrite(STEPPER_PIN_1, LOW);
//                digitalWrite(STEPPER_PIN_2, LOW);
//                digitalWrite(STEPPER_PIN_3, HIGH);
//                digitalWrite(STEPPER_PIN_4, LOW);
//                break;
//            case 2:
//                digitalWrite(STEPPER_PIN_1, LOW);
//                digitalWrite(STEPPER_PIN_2, HIGH);
//                digitalWrite(STEPPER_PIN_3, LOW);
//                digitalWrite(STEPPER_PIN_4, LOW);
//                break;
//            case 3:
//                digitalWrite(STEPPER_PIN_1, HIGH);
//                digitalWrite(STEPPER_PIN_2, LOW);
//                digitalWrite(STEPPER_PIN_3, LOW);
//                digitalWrite(STEPPER_PIN_4, LOW);
//
//
//        }
//    }
//    step_number++;
//    if(step_number > 3){
//        step_number = 0;
//    }
//}
class cub{
public:
    std::vector<std::vector<std::vector<short>>>CUB;
    cub() {
        for (short i = 0; i < 7; i++ ){
            std::vector<std::vector<short>> CUBaux1;
            for(int j = 0 ; j < 7 ; j ++) {
                std::vector<short> CUBaux2;
                for( int k = 0 ; k < 7 ; k ++)
                    CUBaux2.push_back(i);
                CUBaux1.push_back(CUBaux2);
            }
            CUB.push_back(CUBaux1);
        }
    }
};
void afisare( class cub& cub1) {
    FILE *f = fopen("afisare.txt", "w");
    for (int j = 0; j < 3; j++) {
        fprintf(f, "\t\t\t");
        for (int k = 0; k < 3; k++)
            fprintf(f, "%d  ", cub1.CUB[3][j][k]);
        fprintf(f, "\n");
    }
    fprintf(f, "\n");
    for (int j = 0; j < 3; j++) {
        fprintf(f, "\t\t\t");
        for (int k = 0; k < 3; k++)
            fprintf(f, "%d  ", cub1.CUB[5][j][k]);
        fprintf(f, "\n");
    }

    fprintf(f, "\n");
    for (int j = 0; j < 3; j++) {
        for (int k = 0; k < 3; k++)
            fprintf(f, "%d  ", cub1.CUB[4][j][k]);
        fprintf(f, "\t");
        for (int k = 0; k < 3; k++)
            fprintf(f, "%d  ", cub1.CUB[1][j][k]);
        fprintf(f, "\t");
        for (int k = 0; k < 3; k++)
            fprintf(f, "%d  ", cub1.CUB[2][j][k]);
        fprintf(f, "\n");
    }
    fprintf(f, "\n");
    for (int j = 0; j < 3; j++) {
        fprintf(f, "\t\t\t");
        for (int k = 0; k < 3; k++)
            fprintf(f, "%d  ", cub1.CUB[0][j][k]);
        fprintf(f, "\n");
    }
/*
    for (int i = 0; i < 6; i++) {
        fprintf(f, "fata\n");
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++)
                fprintf(f, "%d  ", cub[i][j][k]);
            fprintf(f, "\n");
        }
    }
    */
    fclose(f);
}
class citire{
private:
    class cub cub1;
public:
    class cub cit(){
        cub1.CUB[0][0][0] = 0;  cub1.CUB[0][0][1] = 0;  cub1.CUB[0][0][2] = 0;
        cub1.CUB[0][1][0] = 0;  cub1.CUB[0][1][1] = 0;  cub1.CUB[0][1][2] = 0;
        cub1.CUB[0][2][0] = 0;  cub1.CUB[0][2][1] = 0;  cub1.CUB[0][2][2] = 0;

        cub1.CUB[1][0][0] = 1;  cub1.CUB[1][0][1] = 1;  cub1.CUB[1][0][2] = 1;
        cub1.CUB[1][1][0] = 1;  cub1.CUB[1][1][1] = 1;  cub1.CUB[1][1][2] = 1;
        cub1.CUB[1][2][0] = 1;  cub1.CUB[1][2][1] = 1;  cub1.CUB[1][2][2] = 1;

        cub1.CUB[2][0][0] = 2;  cub1.CUB[2][0][1] = 2;  cub1.CUB[2][0][2] = 2;
        cub1.CUB[2][1][0] = 2;  cub1.CUB[2][1][1] = 2;  cub1.CUB[2][1][2] = 2;
        cub1.CUB[2][2][0] = 2;  cub1.CUB[2][2][1] = 2;  cub1.CUB[2][2][2] = 2;

        cub1.CUB[3][0][0] = 3;  cub1.CUB[3][0][1] = 3;  cub1.CUB[3][0][2] = 3;
        cub1.CUB[3][1][0] = 3;  cub1.CUB[3][1][1] = 3;  cub1.CUB[3][1][2] = 3;
        cub1.CUB[3][2][0] = 3;  cub1.CUB[3][2][1] = 3;  cub1.CUB[3][2][2] = 3;

        cub1.CUB[4][0][0] = 4;  cub1.CUB[4][0][1] = 4;  cub1.CUB[4][0][2] = 4;
        cub1.CUB[4][1][0] = 4;  cub1.CUB[4][1][1] = 4;  cub1.CUB[4][1][2] = 4;
        cub1.CUB[4][2][0] = 4;  cub1.CUB[4][2][1] = 4;  cub1.CUB[4][2][2] = 4;

        cub1.CUB[5][0][0] = 5;  cub1.CUB[5][0][1] = 5;  cub1.CUB[5][0][2] = 5;
        cub1.CUB[5][1][0] = 5;  cub1.CUB[5][1][1] = 5;  cub1.CUB[5][1][2] = 5;
        cub1.CUB[5][2][0] = 5;  cub1.CUB[5][2][1] = 5;  cub1.CUB[5][2][2] = 5;
        return cub1;
}
//    for( short i = 0 ; i < 6 ; i ++ )
//        for(short j = 0 ; j < 3 ; j ++)
//            for(short k = 0 ; k < 3 ; k ++)
//                v[i][j][k] = i;
        //citire_fata_cub(v[i],f);

};

// ///////////////////////////////////////////////////////////////// verificare cub
class Verific{
public:
    short verif(short x, short y, short culoare1, short culoare2) {
        if ((x == culoare2 && y == culoare1) || (x == culoare1 && y == culoare2))
            return 1;
        return 0;
    }
    short verifica(short x, short y, short z, short culoare0, short culoare1,
                     short culoare2) {//verifca daca piesa este cea cautata
        if (x == culoare0 && y == culoare1 && z == culoare2)
            return 1;
        if (x == culoare1 && y == culoare2 && z == culoare0)
            return 1;
        if (x == culoare2 && y == culoare0 && z == culoare1)
            return 1;
        if (x == culoare1 && y == culoare0 && z == culoare2)
            return 1;
        if (x == culoare0 && y == culoare2 && z == culoare1)
            return 1;
        if (x == culoare2 && y == culoare1 && z == culoare0)
            return 1;
        return 0;
    }
    short potrivire_culoare_colturi(class cub& cub1, short culoare0, short culoare1, short culoare2) {
        short ok = 0;
        if (verifica(cub1.CUB[1][0][2], cub1.CUB[2][0][0], cub1.CUB[5][2][2], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[1][0][0], cub1.CUB[4][0][2], cub1.CUB[5][2][0], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[1][2][0], cub1.CUB[4][2][2], cub1.CUB[0][0][0], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[1][2][2], cub1.CUB[2][2][0], cub1.CUB[0][0][2], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[3][2][0], cub1.CUB[5][0][0], cub1.CUB[4][0][0], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[3][2][2], cub1.CUB[2][0][2], cub1.CUB[5][0][2], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[3][0][0], cub1.CUB[0][2][0], cub1.CUB[4][2][0], culoare0, culoare1, culoare2))
            ok++;
        if (verifica(cub1.CUB[3][0][2], cub1.CUB[0][2][2], cub1.CUB[2][2][2], culoare0, culoare1, culoare2))
            ok++;
        if (ok != 1)
            return 0;
        return 1;
    }

    short potrivire_culoare(class cub& cub1, short i, short j) {
        short ok = 0;
        if (verif(cub1.CUB[1][0][1], cub1.CUB[5][2][1], i, j))
            ok++;
        if (verif(cub1.CUB[1][1][0], cub1.CUB[4][1][2], i, j))
            ok++;
        if (verif(cub1.CUB[1][2][1], cub1.CUB[0][0][1], i, j))
            ok++;
        if (verif(cub1.CUB[1][1][2], cub1.CUB[2][1][0], i, j))
            ok++;
        if (verif(cub1.CUB[5][1][2], cub1.CUB[2][0][1], i, j))
            ok++;
        if (verif(cub1.CUB[5][1][0], cub1.CUB[4][0][1], i, j))
            ok++;
        if (verif(cub1.CUB[0][1][2], cub1.CUB[2][2][1], i, j))
            ok++;
        if (verif(cub1.CUB[0][1][0], cub1.CUB[4][2][1], i, j))
            ok++;
        if (verif(cub1.CUB[3][2][1], cub1.CUB[5][0][1], i, j))
            ok++;
        if (verif(cub1.CUB[3][1][0], cub1.CUB[4][1][0], i, j))
            ok++;
        if (verif(cub1.CUB[3][0][1], cub1.CUB[0][2][1], i, j))
            ok++;
        if (verif(cub1.CUB[3][1][2], cub1.CUB[2][1][2], i, j))
            ok++;
        if (ok != 1)
            return 0;
        return 1;
    }

    short VCub(class cub& cub1) {
        if (cub1.CUB[4][1][1] != 4 || cub1.CUB[3][1][1] != 3 || cub1.CUB[2][1][1] != 2 || cub1.CUB[1][1][1] != 1 || cub1.CUB[0][1][1] != 0 ||
            cub1.CUB[5][1][1] != 5)
            return 0;
        if (potrivire_culoare(cub1, 1, 4) == 0)
            return 0;
        if (potrivire_culoare(cub1, 1, 5) == 0)
            return 0;
        if (potrivire_culoare(cub1, 1, 2) == 0)
            return 0;
        if (potrivire_culoare(cub1, 1, 0) == 0)
            return 0;
        if (potrivire_culoare(cub1, 5, 4) == 0)
            return 0;
        if (potrivire_culoare(cub1, 5, 2) == 0)
            return 0;
        if (potrivire_culoare(cub1, 0, 4) == 0)
            return 0;
        if (potrivire_culoare(cub1, 0, 2) == 0)
            return 0;
        if (potrivire_culoare(cub1, 3, 4) == 0)
            return 0;
        if (potrivire_culoare(cub1, 3, 5) == 0)
            return 0;
        if (potrivire_culoare(cub1, 3, 2) == 0)
            return 0;
        if (potrivire_culoare(cub1, 3, 0) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 1, 2, 0) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 1, 2, 5) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 1, 4, 5) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 1, 4, 0) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 3, 5, 2) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 3, 5, 4) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 3, 4, 0) == 0)
            return 0;
        if (potrivire_culoare_colturi(cub1, 3, 2, 0) == 0)
            return 0;
        return 1;
    }
};
// ///////////////////////////////////////////////////////////////// rotire cub
class rotire{
private:
    //class cub cub1;
public:
    void rotire_fata(class cub &cub1, short fata)
    {
        short aux1, aux2 ;
        aux1 = cub1.CUB[fata][0][1];
        aux2 = cub1.CUB[fata][0][2];
        cub1.CUB[fata][0][2] = cub1.CUB[fata][0][0];
        cub1.CUB[fata][0][1] = cub1.CUB[fata][1][0];
        cub1.CUB[fata][0][0] = cub1.CUB[fata][2][0];

        cub1.CUB[fata][2][0] = cub1.CUB[fata][2][2];
        cub1.CUB[fata][1][0] = cub1.CUB[fata][2][1];

        cub1.CUB[fata][2][1] = cub1.CUB[fata][1][2];
        cub1.CUB[fata][2][2] = aux2;

        cub1.CUB[fata][1][2] = aux1;
    }
    void right_face(class cub& cub1){

        short aux0 = cub1.CUB[3][0][2], aux1 = cub1.CUB[3][1][2], aux2 = cub1.CUB[3][2][2];
        for( short i = 0 ; i < 3 ; i ++ )
        {
            cub1.CUB[3][i][2] = cub1.CUB[5][i][2];
            cub1.CUB[5][i][2] = cub1.CUB[1][i][2];
            cub1.CUB[1][i][2] = cub1.CUB[0][i][2];
        }
        cub1.CUB[0][0][2] = aux0;
        cub1.CUB[0][1][2] = aux1;
        cub1.CUB[0][2][2] = aux2;
//@    if(dreapta == 5 || dreapta == 3)
//      mutare_up(dreapta);
//    else
//      mutare_down(dreapta);
//@    delay(2000);
        rotire_fata(cub1, 2);
    }

    void left_face(class cub &cub1){

        short aux0 = cub1.CUB[3][0][0], aux1 = cub1.CUB[3][1][0], aux2 = cub1.CUB[3][2][0];
        for( short i = 0 ; i < 3 ; i ++ )
        {
            cub1.CUB[3][i][0] = cub1.CUB[5][i][0];
            cub1.CUB[5][i][0] = cub1.CUB[1][i][0];
            cub1.CUB[1][i][0] = cub1.CUB[0][i][0];
        }
        cub1.CUB[0][0][0] = aux0;
        cub1.CUB[0][1][0] = aux1;
        cub1.CUB[0][2][0] = aux2;

        rotire_fata(cub1, 4);
        rotire_fata(cub1, 4);
        rotire_fata(cub1, 4);
//@    if(stanga == 3 || stanga == 5)
//       mutare_down(stanga);
//    else
//       mutare_up(stanga);
//@    delay(2000);
    }

    void back_face(class cub& cub1)
    {
        short aux0 = cub1.CUB[5][0][0], aux1 = cub1.CUB[5][0][1], aux2 = cub1.CUB[5][0][2];
        for( short i = 0 ; i < 3 ; i ++ ){
            cub1.CUB[5][0][i] = cub1.CUB[2][i][2];
        }
        for( short i = 0 ; i < 3 ; i ++ ){
            cub1.CUB[2][2-i][2] = cub1.CUB[0][2][i];
        }
        for( short i = 0 ; i < 3 ; i ++ ) {
            cub1.CUB[0][2][i] = cub1.CUB[4][i][0];
        }
        cub1.CUB[4][0][0] = aux2 ;
        cub1.CUB[4][1][0] = aux1 ;
        cub1.CUB[4][2][0] = aux0 ;

        rotire_fata(cub1, 3);
//@    if(spate == 6 || spate == 4)
//       mutare_down(spate);
//    else
//       mutare_up(spate);
//@    delay(2000);
    }

    void front_face(class cub& cub1)
    {
        short aux0 = cub1.CUB[5][2][0], aux1 = cub1.CUB[5][2][1], aux2 = cub1.CUB[5][2][2];
        for( short i = 0 ; i < 3 ; i ++ ){
            cub1.CUB[5][2][i] = cub1.CUB[2][i][0];
        }
        for( short i = 0 ; i < 3 ; i ++ ){
            cub1.CUB[2][2-i][0] = cub1.CUB[0][0][i];
        }
        for( short i = 0 ; i < 3 ; i ++ ) {
            cub1.CUB[0][0][i] = cub1.CUB[4][i][2];
        }
        cub1.CUB[4][0][2] = aux2 ;
        cub1.CUB[4][1][2] = aux1 ;
        cub1.CUB[4][2][2] = aux0 ;

        rotire_fata(cub1, 1);
        rotire_fata(cub1, 1);
        rotire_fata(cub1, 1);
//@    if(fataa == 4 || fataa == 6)
//        mutare_up(fataa);
//    else
//        mutare_down(fataa);
//@    delay(2000);
    }

    void up_face(class cub& cub1)
    {
        short aux0 = cub1.CUB[3][2][0], aux1 = cub1.CUB[3][2][1], aux2 = cub1.CUB[3][2][2];
        for( short i = 0 ; i < 3 ; i ++ )
        {
            cub1.CUB[3][2][i] = cub1.CUB[4][0][2-i];
        }
        for( short i = 0 ; i < 3 ; i ++ )
        {
            cub1.CUB[4][0][i] = cub1.CUB[1][0][i];
            cub1.CUB[1][0][i]= cub1.CUB[2][0][i];
        }
        cub1.CUB[2][0][0] = aux2 ;
        cub1.CUB[2][0][1] = aux1 ;
        cub1.CUB[2][0][2] = aux0 ;

        rotire_fata(cub1, 5);
        //@mutare_down(sus);
        //@delay(2000);

    }

    void down_face(class cub &cub1)
    {
        short aux0 = cub1.CUB[3][0][0], aux1 = cub1.CUB[3][0][1], aux2 = cub1.CUB[3][0][2];
        for( short i = 0 ; i < 3 ; i ++ )
        {
            cub1.CUB[3][0][i] = cub1.CUB[4][2][2-i];
        }
        for( short i = 0 ; i < 3 ; i ++ )
        {
            cub1.CUB[4][2][i] = cub1.CUB[1][2][i];
            cub1.CUB[1][2][i] = cub1.CUB[2][2][i];
        }
        cub1.CUB[2][2][0] = aux2 ;
        cub1.CUB[2][2][1] = aux1 ;
        cub1.CUB[2][2][2] = aux0 ;

        rotire_fata(cub1, 0);
        rotire_fata(cub1, 0);
        rotire_fata(cub1, 0);
        //@mutare_up(jos);
        //@delay(2000);
    }

    void right_face_prim(class cub& cub1){
        right_face( cub1);
        right_face( cub1);
        right_face( cub1);
        //mutare_up(dreapta);
        // delay(2000);
    }
    void down_face_prim(class cub& cub1){
        down_face( cub1);
        down_face( cub1);
        down_face( cub1);
        // mutare_down(jos);
        //delay(2000);
    }
    void up_face_prim(class cub& cub1){
        up_face( cub1);
        up_face( cub1);
        up_face( cub1);
        // mutare_up(sus);
        //delay(2000);
    }
    void front_face_prim(class cub& cub1){
        front_face( cub1);
        front_face( cub1);
        front_face( cub1);
        // mutare_up(fataa);
        //delay(2000);
    }
    void back_face_prim(class cub& cub1){
        back_face( cub1);
        back_face( cub1);
        back_face( cub1);
        //mutare_down(spate);
        //delay(2000);
    }
    void left_face_prim(class cub& cub1){
        left_face( cub1);
        left_face( cub1);
        left_face( cub1);
        //mutare_down(stanga);
        //delay(2000);
    }
    void middle_face(class cub& cub1) {
        short aux0 = cub1.CUB[3][1][0], aux1 = cub1.CUB[3][1][1], aux2 = cub1.CUB[3][1][2];
        for (short i = 0; i < 3; i++) {
            cub1.CUB[3][1][i] = cub1.CUB[4][1][2 - i];
        }
        for (short i = 0; i < 3; i++) {
            cub1.CUB[4][1][i] = cub1.CUB[1][1][i];
            cub1.CUB[1][1][i] = cub1.CUB[2][1][i];
        }
        cub1.CUB[2][1][0] = aux2;
        cub1.CUB[2][1][1] = aux1;
        cub1.CUB[2][1][2] = aux0;
        //@mutare_up(sus);
        //@mutare_down(jos);
        short aux = dreapta;
        dreapta = spate;
        spate = stanga;
        stanga = fataa;
        fataa = aux;
    }
};
// ///////////////////////////////////////////////////////////////// pas 1
class pas1 : public rotire{
public:
    void cruce_maker(class cub& cub1) {
        short culoare1 = cub1.CUB[1][1][1], culoare2 = cub1.CUB[0][1][1];
        if (cub1.CUB[1][2][1] == culoare2 && cub1.CUB[0][0][1] == culoare1)
            front_face(cub1);
        //verificare lateral jos
        if ((cub1.CUB[0][1][2] == culoare2 && cub1.CUB[2][2][1] == culoare1) ||
            (cub1.CUB[0][1][2] == culoare1 && cub1.CUB[2][2][1] == culoare2))
            right_face(cub1);
        if ((cub1.CUB[0][1][0] == culoare1 && cub1.CUB[4][2][1] == culoare2) ||
            (cub1.CUB[0][1][0] == culoare2 && cub1.CUB[4][2][1] == culoare1))
            left_face(cub1);
        //verificare spatele cubului
        if ((cub1.CUB[0][2][1] == culoare2 && cub1.CUB[3][0][1] == culoare1) ||
            (cub1.CUB[0][2][1] == culoare1 && cub1.CUB[3][0][1] == culoare2)) {
            back_face(cub1);
            back_face(cub1);
        }
        if ((cub1.CUB[3][1][2] == culoare1 && cub1.CUB[2][1][2] == culoare2) ||
            (cub1.CUB[3][1][2] == culoare2 && cub1.CUB[2][1][2] == culoare1)) {
            right_face_prim(cub1);
            up_face(cub1);
            right_face(cub1);
        }
        if ((cub1.CUB[4][1][0] == culoare2 && cub1.CUB[3][1][0] == culoare1) ||
            (cub1.CUB[4][1][0] == culoare1 && cub1.CUB[3][1][0] == culoare2)) {
            left_face_prim(cub1);
            up_face_prim(cub1);
            left_face(cub1);
        }

        if ((cub1.CUB[5][0][1] == culoare1 && cub1.CUB[3][2][1] == culoare2) ||
            (cub1.CUB[5][0][1] == culoare2 && cub1.CUB[3][2][1] == culoare1)) {
            up_face(cub1);
            up_face(cub1);
        }
        if ((cub1.CUB[5][1][2] == culoare2 && cub1.CUB[2][0][1] == culoare1) ||
            (cub1.CUB[5][1][2] == culoare1 && cub1.CUB[2][0][1] == culoare2))
            up_face(cub1);
        if ((cub1.CUB[5][1][0] == culoare1 && cub1.CUB[4][0][1] == culoare2) ||
            (cub1.CUB[5][1][0] == culoare2 && cub1.CUB[4][0][1] == culoare1))
            up_face_prim(cub1);

        if (cub1.CUB[1][1][0] == culoare1 && cub1.CUB[4][1][2] == culoare2)
            front_face(cub1);
        if (cub1.CUB[1][0][1] == culoare1 && cub1.CUB[5][2][1] == culoare2) {
            front_face(cub1);
            front_face(cub1);
        }
        if (cub1.CUB[1][1][2] == culoare1 && cub1.CUB[2][1][0] == culoare2) {
            front_face_prim(cub1);
        }
        //daca sunt pe dos culorile
        if (cub1.CUB[1][1][0] == culoare2 && cub1.CUB[4][1][2] == culoare1) {
            left_face(cub1);
            up_face_prim(cub1);
            left_face_prim(cub1);
            front_face(cub1);
            front_face(cub1);
        }
        if (cub1.CUB[1][0][1] == culoare2 && cub1.CUB[5][2][1] == culoare1) {
            up_face_prim(cub1);
            right_face_prim(cub1);
            front_face_prim(cub1);
            right_face(cub1);
        }
        if (cub1.CUB[1][1][2] == culoare2 && cub1.CUB[2][1][0] == culoare1) {
            right_face(cub1);
            up_face(cub1);
            right_face_prim(cub1);
            front_face(cub1);
            front_face(cub1);
        }
        //sf pe dos

    }

    void cruce(class cub& cub1) {
        cruce_maker(cub1);//prima piesa
        // afisare(cub);
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        cruce_maker(cub1);//a doua piesa
        //afisare(cub);
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        cruce_maker(cub1);//a treia piesa
        // afisare(cub);
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        cruce_maker(cub1);//a patra piesa
        //readucerea cubului la pozitia initiala
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        if (cub1.CUB[1][2][1] != cub1.CUB[1][1][1] || cub1.CUB[2][2][1] != cub1.CUB[2][1][1] || cub1.CUB[4][1][1] != cub1.CUB[4][2][1] ||
            cub1.CUB[3][1][1] != cub1.CUB[3][0][1])
            //Serial.print("Eroare la pasul 1");
            std::cout << "Eroare la pasul 1\n";
        else if (cub1.CUB[0][1][1] != cub1.CUB[0][0][1] || cub1.CUB[0][0][1] != cub1.CUB[0][1][2] || cub1.CUB[0][1][2] != cub1.CUB[0][2][1] ||
                 cub1.CUB[0][2][1] != cub1.CUB[0][1][0])
            //Serial.print("Eroare la pasul 1");
            std::cout << "Eroare la pasul 1\n";
    }
};
// ///////////////////////////////////////////////////////////////// pas 2
class pas2 : public rotire{
public:
    short verificare(short x, short y, short z, short culoare0, short culoare1,
                     short culoare2) {//verifca daca piesa este cea cautata
        if (x == culoare0 && y == culoare1 && z == culoare2)
            return 1;
        if (x == culoare1 && y == culoare2 && z == culoare0)
            return 1;
        if (x == culoare2 && y == culoare0 && z == culoare1)
            return 1;
        if (x == culoare1 && y == culoare0 && z == culoare2)
            return 1;
        if (x == culoare0 && y == culoare2 && z == culoare1)
            return 1;
        if (x == culoare2 && y == culoare1 && z == culoare0)
            return 1;
        return 0;
    }

    void colt(class cub& cub1) {
        //fixeaza colturile
        if (verificare(cub1.CUB[2][2][2], cub1.CUB[3][0][2], cub1.CUB[0][2][2], 0, cub1.CUB[2][1][1], cub1.CUB[1][1][1])) {
            back_face(cub1);
            up_face(cub1);
            back_face_prim(cub1);
        }
        if (verificare(cub1.CUB[4][2][0], cub1.CUB[3][0][0], cub1.CUB[0][2][0], 0, cub1.CUB[2][1][1], cub1.CUB[1][1][1])) {
            left_face_prim(cub1);
            up_face(cub1);
            left_face(cub1);
        }
        if (verificare(cub1.CUB[1][2][0], cub1.CUB[0][0][0], cub1.CUB[4][2][2], 0, cub1.CUB[2][1][1], cub1.CUB[1][1][1])) {
            left_face(cub1);
            up_face_prim(cub1);
            left_face_prim(cub1);
        }
        short nr = 0;
        while (verificare(cub1.CUB[1][2][2], cub1.CUB[0][0][2], cub1.CUB[2][2][0], 0, cub1.CUB[1][1][1], cub1.CUB[2][1][1]) == 0) {
            right_face(cub1);
            up_face_prim(cub1);
            right_face_prim(cub1);
            nr++;
            if (nr == 4)
                up_face(cub1);
            if (nr == 8)
                break;
        }
        if (nr == 8)
            //Serial.print("Eroare la pasul 2\n");
            std::cout << "Eroare la pasul 2\n";
        nr = 0;
        while (cub1.CUB[0][0][2] != 0) {
            right_face(cub1);
            up_face(cub1);
            right_face_prim(cub1);
            up_face_prim(cub1);
            right_face(cub1);
            up_face(cub1);
            right_face_prim(cub1);
            nr++;
            if (nr == 8)
                break;
        }
        if (nr == 8)
            //Serial.print("Eroare la pasul 2'\n");
            std::cout << "Eroare la pasul 2\n";
    }

    void completare_alb(class cub& cub1) {
        colt(cub1);//primul colt
        //afisare(cub);
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        colt(cub1);//al doilea colt
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        colt(cub1);//al treilea colt
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        colt(cub1);//al patrulea colt
        //readucerea la pozitia initiala
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        //afisare(cub);
    }
};
// ///////////////////////////////////////////////////////////////// pas 3
class pas3: public rotire,public Verific{
public:
    void pozitionare_piesa_dreapta(class cub& cub1) {
        up_face(cub1);
        right_face(cub1);
        up_face_prim(cub1);
        right_face_prim(cub1);
        up_face_prim(cub1);
        front_face(cub1);
        up_face(cub1);
        front_face_prim(cub1);
    }

    void pozitionare_piesa_stanga(class cub& cub1) {
        up_face_prim(cub1);
        left_face(cub1);
        up_face(cub1);
        left_face_prim(cub1);
        up_face(cub1);
        front_face_prim(cub1);
        up_face_prim(cub1);
        front_face(cub1);
    }

    void layer2_peace_by_peace(class cub& cub1) {
        if (cub1.CUB[1][1][2] == cub1.CUB[2][1][1] && cub1.CUB[2][1][0] == cub1.CUB[1][1][1])
            pozitionare_piesa_dreapta(cub1);
        if (verif(cub1.CUB[1][1][1], cub1.CUB[2][1][1], cub1.CUB[2][1][2], cub1.CUB[3][1][2])) {
            up_face(cub1);
            down_face(cub1);
            middle_face(cub1);
            pozitionare_piesa_dreapta(cub1);//scot piesa pe care o caut
            //repozitionare cub
            up_face_prim(cub1);
            down_face_prim(cub1);
            middle_face(cub1);
            middle_face(cub1);
            middle_face(cub1);
        }
        if (verif(cub1.CUB[1][1][1], cub1.CUB[2][1][1], cub1.CUB[4][1][0], cub1.CUB[3][1][0])) {
            up_face(cub1);
            down_face(cub1);
            middle_face(cub1);
            up_face(cub1);
            down_face(cub1);
            middle_face(cub1);
            pozitionare_piesa_dreapta(cub1);
            up_face(cub1);
            down_face(cub1);
            middle_face(cub1);
            up_face(cub1);
            down_face(cub1);
            middle_face(cub1);
        }
        if (verif(cub1.CUB[1][1][1], cub1.CUB[2][1][1], cub1.CUB[1][1][0], cub1.CUB[4][1][2])) {
            up_face_prim(cub1);
            down_face_prim(cub1);
            middle_face(cub1);
            middle_face(cub1);
            middle_face(cub1);
            pozitionare_piesa_dreapta(cub1);
            up_face(cub1);
            down_face(cub1);
            middle_face(cub1);
        }
        if (cub1.CUB[1][1][1] != cub1.CUB[1][1][2] || cub1.CUB[2][1][1] != cub1.CUB[2][1][0] ||
        cub1.CUB[1][1][0] != cub1.CUB[1][1][1] || cub1.CUB[4][1][1] != cub1.CUB[4][1][2]) {
            for (short i = 0; i < 4; i++) {
                for (short j = 0; j < 4; j++) {
                    if (cub1.CUB[1][0][1] == cub1.CUB[1][1][1] && cub1.CUB[5][2][1] == cub1.CUB[2][1][1])
                        pozitionare_piesa_dreapta(cub1);
                    up_face(cub1);
                }
                middle_face(cub1);
                down_face(cub1);
            }
            for (short i = 0; i < 4; i++) {
                for (short j = 0; j < 4; j++) {
                    if (cub1.CUB[1][0][1] == cub1.CUB[1][1][1] && cub1.CUB[5][2][1] == cub1.CUB[4][1][1])
                        pozitionare_piesa_stanga(cub1);
                    up_face(cub1);
                }
                middle_face(cub1);
                down_face(cub1);
            }
        }
    }

    void layer2(class cub& cub1) {
        layer2_peace_by_peace(cub1);//piesa 1
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        layer2_peace_by_peace(cub1);//piesa 2
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        layer2_peace_by_peace(cub1);//piesa 3
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        layer2_peace_by_peace(cub1);//piesa 4
        //repozitionarea cubului
        up_face(cub1);
        middle_face(cub1);
        down_face(cub1);
        //afisare(cub);
    }
};
// ///////////////////////////////////////////////////////////////// pas 4
class pas4 : public rotire{
public:
    void algorithm(class cub& cub1) {
        front_face_prim(cub1);
        up_face(cub1);
        right_face(cub1);
        up_face_prim(cub1);
        right_face_prim(cub1);
        front_face(cub1);
    }

    void top_x(class cub& cub1) {
        short ok = 0;
        //5 reprezshorta culoarea galben
        if (cub1.CUB[5][1][0] != 5 && cub1.CUB[5][1][2] != 5 && cub1.CUB[5][0][1] != 5 && cub1.CUB[5][2][1] != 5)
            algorithm(cub1);
        while (cub1.CUB[5][1][0] != 5 || cub1.CUB[5][1][2] != 5 || cub1.CUB[5][0][1] != 5 || cub1.CUB[5][2][1] != 5) {
            ok++;
            for (short i = 0; i < 4; i++) {
                if (cub1.CUB[5][0][1] == 5 && cub1.CUB[5][1][0] == 5 && cub1.CUB[5][1][2] != 5)
                    algorithm(cub1);
                up_face(cub1);
            }
            if (cub1.CUB[5][1][0] == 5 && cub1.CUB[5][1][2] == 5 && cub1.CUB[5][2][1] != 5)
                algorithm(cub1);
            if (cub1.CUB[5][1][0] == 5 && cub1.CUB[5][1][2] == 5 && cub1.CUB[5][2][1] != 5)
                algorithm(cub1);
            up_face(cub1);
            if (ok == 8)
                break;
        }
        if (ok == 8) {
            //Serial.print("Eroare la pasul 4\n");
            std::cout << "Eroare la pasul 4\n";
        }
    }
};
// ///////////////////////////////////////////////////////////////// pas 5
class pas5 : public rotire{
public:
    void algorithm_pasul5(class cub& cub1) {
        right_face(cub1);
        up_face(cub1);
        right_face_prim(cub1);
        up_face(cub1);
        right_face(cub1);
        up_face(cub1);
        up_face(cub1);
        right_face_prim(cub1);
    }

    void creare_fata_galbena(class cub& cub1) {
        short ok = 0;
        //5 reprezshorta culoarea galben
        while (cub1.CUB[5][0][0] != 5 || cub1.CUB[5][0][2] != 5 || cub1.CUB[5][2][2] != 5) {
            ok++;
            for (short i = 0; i < 4; i++)//caz 1
            {
                if (cub1.CUB[5][2][0] == 5 && cub1.CUB[5][0][0] != 5 && cub1.CUB[5][0][2] != 5 && cub1.CUB[5][2][2] != 5)
                    algorithm_pasul5(cub1);
                up_face(cub1);
            }
            for (short i = 0; i < 4; i++)//caz 2
            {
                if (cub1.CUB[4][0][2] == 5 && cub1.CUB[5][2][0] != 5 && cub1.CUB[5][0][0] != 5 && cub1.CUB[5][0][2] != 5 &&
                    cub1.CUB[5][2][2] != 5)
                    algorithm_pasul5(cub1);
                up_face(cub1);
            }
            for (short i = 0; i < 4; i++)//caz 3
            {
                if (cub1.CUB[1][0][0] == 5 && cub1.CUB[5][0][0] == 5 && cub1.CUB[5][0][2] == 5 && cub1.CUB[5][2][2] != 5)
                    algorithm_pasul5(cub1);
                up_face(cub1);
            }
            for (short i = 0; i < 4; i++)//caz 4
            {
                if (cub1.CUB[1][0][0] == 5 && cub1.CUB[5][0][0] == 5 && cub1.CUB[5][0][2] != 5 && cub1.CUB[5][2][2] == 5)
                    algorithm_pasul5(cub1);
                up_face(cub1);
            }
            for (short i = 0; i < 4; i++)//caz 5
            {
                if (cub1.CUB[1][0][0] == 5 && cub1.CUB[5][0][0] != 5 && cub1.CUB[5][0][2] == 5 && cub1.CUB[5][2][2] == 5)
                    algorithm_pasul5(cub1);
                up_face(cub1);
            }
            if (ok == 6)
                break;
        }
        if (ok == 6)
            //Serial.print("Eroare la pasul 5\n");
            std::cout << "Eroare la pasul 5\n";
        //afisare(cub);
    }
};
// ///////////////////////////////////////////////////////////////// pas 6
class pas6 : public rotire{
public:
    void algorithm_pasul6(class cub& cub1) {
        right_face_prim(cub1);
        front_face_prim(cub1);
        right_face_prim(cub1);
        back_face(cub1);
        back_face(cub1);
        right_face(cub1);
        front_face(cub1);
        right_face_prim(cub1);
        back_face(cub1);
        back_face(cub1);
        right_face(cub1);
        right_face(cub1);
        up_face_prim(cub1);
    }

    short verificare_pozitie_colturi(class cub& cub1) {
        if (cub1.CUB[1][0][0] != cub1.CUB[1][1][1] || cub1.CUB[4][0][2] != cub1.CUB[4][1][1])
            return 0;
        if (cub1.CUB[1][0][2] != cub1.CUB[1][1][1] || cub1.CUB[2][0][0] != cub1.CUB[2][1][1])
            return 0;
        if (cub1.CUB[3][2][0] != cub1.CUB[3][1][1] || cub1.CUB[4][0][0] != cub1.CUB[4][1][1])
            return 0;
        if (cub1.CUB[2][0][2] != cub1.CUB[2][1][1] || cub1.CUB[3][2][2] != cub1.CUB[3][1][1])
            return 0;
        return 1;
    }

    void pozitionare_colturi(class cub& cub1) {
        short ok = 0, nr = 0;
        while (ok < 2) {
            ok = 0;
            up_face(cub1);
            if (cub1.CUB[1][0][0] == cub1.CUB[1][1][1] && cub1.CUB[4][0][2] == cub1.CUB[4][1][1])
                ok++;
            if (cub1.CUB[1][0][2] == cub1.CUB[1][1][1] && cub1.CUB[2][0][0] == cub1.CUB[2][1][1])
                ok++;
            if (cub1.CUB[3][2][0] == cub1.CUB[3][1][1] && cub1.CUB[4][0][0] == cub1.CUB[4][1][1])
                ok++;
            if (cub1.CUB[2][0][2] == cub1.CUB[2][1][1] && cub1.CUB[3][2][2] == cub1.CUB[3][1][1])
                ok++;
            nr++;
            if (nr == 6)
                break;
        }
        if (nr == 6)
            //Serial.print("Eroare la pasul 6\n");
            std::cout << "Eroare la pasul 6\n";
        nr = 0;
        while (verificare_pozitie_colturi(cub1) == 0) {
            for (short i = 0; i < 4; i++) {
                if (cub1.CUB[1][0][0] != cub1.CUB[1][1][1] && cub1.CUB[1][0][2] != cub1.CUB[1][1][1])
                    algorithm_pasul6(cub1);
                up_face(cub1);
                middle_face(cub1);
                down_face(cub1);
            }
            if (cub1.CUB[1][0][0] == cub1.CUB[1][1][1] && cub1.CUB[1][0][2] != cub1.CUB[1][1][1])
                algorithm_pasul6(cub1);
            else {
                up_face(cub1);
                middle_face(cub1);
                down_face(cub1);
                if (cub1.CUB[1][0][0] == cub1.CUB[1][1][1] && cub1.CUB[1][0][2] != cub1.CUB[1][1][1])
                    algorithm_pasul6(cub1);
                up_face_prim(cub1);
                middle_face(cub1);
                middle_face(cub1);
                middle_face(cub1);
                down_face_prim(cub1);
            }
            nr++;
            if (nr == 6)
                break;
        }
        if (nr == 6)
            //Serial.print("Eroare la pasul 6'\n");
            std::cout << "Eroare la pasul 6'\n";
        //afisare(cub);
    }
};
// ///////////////////////////////////////////////////////////////// pas 7
class pas7: public rotire{
public:
    void algorithm_pasul7(class cub& cub1) {
        front_face_prim(cub1);
        front_face_prim(cub1);
        up_face(cub1);
        left_face_prim(cub1);
        right_face_prim(cub1);
        front_face_prim(cub1);
        front_face_prim(cub1);
        left_face(cub1);
        right_face(cub1);
        up_face(cub1);
        front_face_prim(cub1);
        front_face_prim(cub1);
    }

    void aranjare_muchii(class cub& cub1) {
        short ok = 0, nr = 0;
        if (cub1.CUB[3][2][1] != cub1.CUB[3][1][1] && cub1.CUB[2][0][1] != cub1.CUB[2][1][1] && cub1.CUB[1][0][1] != cub1.CUB[1][1][1] &&
            cub1.CUB[4][0][1] != cub1.CUB[4][1][1])
            algorithm_pasul7(cub1);
        while (cub1.CUB[3][2][1] != cub1.CUB[3][1][1]) {
            nr++;//pentru a aduce cubul la pozitia initiala
            up_face(cub1);
            middle_face(cub1);
            down_face(cub1);
            if (nr == 4)
                break;
        }
        if (nr == 4)
            //Serial.print("Eroare la pasul 7\n");
            std::cout << "Eroare la pasul 7\n";
        while (cub1.CUB[1][0][1] != cub1.CUB[1][1][1] || cub1.CUB[2][0][1] != cub1.CUB[2][1][1]) {
            algorithm_pasul7(cub1);
            ok++;
            if (ok == 6)
                break;
        }
        if (ok == 6)
            //Serial.print("Eroare la pasul 7\n");
            std::cout << "Eroare la pasul 7\n";
        for (short i = 0; i < 4 - nr; i++) {//pentru a readuce cubul la pozitia initiala
            up_face(cub1);
            middle_face(cub1);
            down_face(cub1);
        }
        //afisare(cub);
    }
};
// /////////////////////////////////////////////////////////////////
//void amestecare(short cub[7][7][7]){
//  int nr = 0;
//  while(true){
//  delay(60);
//     lcd.setCursor(0, 0);
//    bool presst1 = digitalRead(button1);
//    if(presst1 == false){
//      //Serial.print("hello1\n");
//      //right_face(cub);
//      nr ++;
//      while(digitalRead(button1) == false){
//        ;
//      }
//    }
//    bool presst2 = digitalRead(button2);
//    if(nr == 7)
//    {
//      nr = 0;
//    }
//    if(nr == 0){
//      //lcd.setCursor(0, 0);
//      lcd.print("fata           ");
//
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      front_face(cub);
//      while(digitalRead(button2) == false){
//        ;
//      }
//      //delay(200);
//    }
//    }
//    if(nr == 1){
//      //lcd.setCursor(0, 0);
//      lcd.print("stanga         ");
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      left_face(cub);
//      while(digitalRead(button2) == false){
//        ;
//      }
//     // delay(200);
//    }
//    }
//    if(nr == 2){
//      //lcd.setCursor(0, 0);
//      lcd.print("dreapta        ");
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      right_face(cub);
//      while(digitalRead(button2) == false){
//        ;
//      }
//    }
//    }
//    if(nr == 3){
//      //lcd.setCursor(0, 0);
//      lcd.print("spate          ");
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      back_face(cub);
//      while(digitalRead(button2) == false){
//        ;
//      }
//    }
//    }
//    if(nr == 4){
//      //lcd.setCursor(0, 0);
//      lcd.print("sus            ");
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      up_face(cub);
//      while(digitalRead(button2) == false){
//        ;
//      }
//    }
//    }
//    if(nr == 5){
//     // lcd.setCursor(0, 0);
//      lcd.print("jos            ");
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      down_face(cub);
//      while(digitalRead(button2) == false){
//        ;
//      }
//    }
//    }
//    if(nr == 6){
//      //lcd.setCursor(0, 0);
//      lcd.print("Start Amestecare");
//      presst2 = digitalRead(button2);
//      if(presst2 == false){
//      break;
//      while(digitalRead(button2) == false){
//        ;
//      }
//      }
//    }
//  }
//}
////////////////////////////////
class maine: public pas1, public pas2, public pas3, public  pas4, public pas5, public pas6, public pas7, public citire{
private:
    class cub cub1;
public:
    void rezolvare(){
                cub1 = cit();
        if(VCub(cub1) == 0)
            //Serial.print("Cubul shortrodus nu este corect\n");
            std::cout<<"Cubul shortrodus nu este corect\n";
        else {
            //Serial.print("Cubul este bun\n");
            std::cout<<"Cubul este bun\n";
            //@amestecare(cub);
      pas1::front_face(cub1);
      pas1::back_face(cub1);
      pas1::right_face(cub1);
      pas1::left_face(cub1);
      pas1::up_face(cub1);
      pas1::down_face(cub1);
      pas1::middle_face(cub1);
      pas1::right_face(cub1);
      pas1::front_face(cub1);
      pas1::back_face(cub1);
      //pas1::right_face(cub1);
     // pas1::left_face(cub1);
     int aux;
            //afisare(cub1);
            //std::cin >> aux;
            cruce(cub1);//pasul1
            //Serial.print("Gata pasul 1\n");
            //afisare(cub1);
            //std::cin >> aux;
            std::cout << "Gata pasul 1\n";
            completare_alb(cub1);//pasul2
            //Serial.print("Gata pasul 2\n");
            //afisare(cub1);
            //std::cin >> aux;
            std::cout << "Gata pasul 2\n";
            layer2(cub1);//pasul3
            //Serial.print("Gata pasul 3\n");
            afisare(cub1);
            //std::cin >> aux;
            std::cout << "Gata pasul 3\n";
            top_x(cub1);//pas4
            //afisare(cub1);
            //std::cin >> aux;
            //Serial.print("Gata pasul 4\n");
            std::cout << "Gata pasul 4\n";
            creare_fata_galbena(cub1);//pasul 5
            afisare(cub1);
            //std::cin >> aux;
            //Serial.print("Gata pasul 5\n");
            std::cout << "Gata pasul 5\n";
            pozitionare_colturi(cub1);//pasul 6
            //afisare(cub1);
            //std::cin >> aux;
            //Serial.print("Gata pasul 6\n");
            std::cout << "Gata pasul 6\n";
            aranjare_muchii(cub1);//pasul 7
        }
        //Serial.print("Cubul este gata\n");
        std::cout << "Cubul este gata\n";
        //@delay(3000000);
        afisare(cub1);
    }

};
int main() {
/*@
  digitalWrite(jos, HIGH);
  digitalWrite(sus, HIGH);
  digitalWrite(stanga, HIGH);
  digitalWrite(dreapta, HIGH);
  digitalWrite(fataa, HIGH);
  digitalWrite(spate, HIGH);
  */
  //lcd.print("olla");
  //delay(200);
 class maine CUB;
 CUB.rezolvare();

 //reglare(stanga , 8);
 //delay(300000);
//  mutare(dreapta);
//  delay(2000);
//  mutare(spate);
//  delay(2000);
//  mutare(stanga);
//  delay(2000);
//  mutare(fataa);
//  delay(2000);
//  mutare(jos);
//  delay(2000);
//  mutare(sus);
//  delay(2000);
//  delay(4000);

}
